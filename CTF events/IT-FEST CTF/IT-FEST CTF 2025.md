# IT-FEST CTF 2025 Write-up

## HARDWARE 

### Task - i2c

Just i2c and nothing more

    LOGIC ANALYZER CAPTURE: I2C BUS
    ADDR: 0x3C (Write Mode)
    --------------------------------
    [CMD] Control: 0x00, Data: 0xAE
    [CMD] Control: 0x00, Data: 0xD5
    [CMD] Control: 0x00, Data: 0x80
    [CMD] Control: 0x00, Data: 0xA8
    [CMD] Control: 0x00, Data: 0x3F
    [CMD] Control: 0x00, Data: 0xD3
    [CMD] Control: 0x00, Data: 0x00
    [CMD] Control: 0x00, Data: 0x40
    [CMD] Control: 0x00, Data: 0x8D
    [CMD] Control: 0x00, Data: 0x14
    [CMD] Control: 0x00, Data: 0x20
    [CMD] Control: 0x00, Data: 0x00
    [CMD] Control: 0x00, Data: 0xAF
    [CMD] Control: 0x00, Data: 0xB0 (Set Page Start)
    [CMD] Control: 0x00, Data: 0x00 (Set Lower Column)
    [CMD] Control: 0x00, Data: 0x10 (Set Higher Column)
    ---- croped for brevity ----

Solution: 

The I2C traffic targets address 0x3C (typical SSD1306 OLED controller) in write mode. 
Commands like 0xAE (display off), 0xD5/A8/3F (timing/multiplex), 0xA4 (normal display), 0x20 (horizontal addressing), and 0xAF (display on) initialize a 128x64 monochrome OLED. 
Page addressing (0xB0-B7) sets 8 display pages, each with column address 0x0010 (16-143 decimal) for 128 bytes of 8-bit vertical pixel data.

Script extracts DATA bytes (control 0x40) and reconstruct the 128x64 bitmap.

    data = []
    # Page B0 (mostly 0x00 - blank)
    data.extend([0x00] * 128)
    # Page B1 (mostly 0x00 - blank) 
    data.extend([0x00] * 128)
    # Page B2 (mostly 0x00 - blank)
    data.extend([0x00] * 128)
    # Page B3 (flag data starts here - key non-zero bytes)
    page_b3 = [0x00]*112 + [0x40,0xF0,0x50,0x00,0x20,0x10,0xF0,0x00,0x00,0x20,0x10,0x90,0x90,0x60,0x00,0x00,0xF8,0x08,0x40,0xF0,0x40,0x00,0xC0,0x00,0x00,0x00,0xC0,0x00,0x00,0xC0,0x40,0x40,0x00,0xC0,0xC0,0x40,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x40,0x40,0x40,0x80,0x00,0x40,0xF0,0x50,0x40,0xF0,0x50,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0xC0,0x00,0x80,0x40,0x40,0x40,0x80,0x00,0x00,0xC0,0x00,0x00,0x00,0xC0,0x00,0x00,0xC0,0x40,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x40,0x40,0xC0,0x00,0x00,0xD0,0x00,0x00,0xF0,0x00,0x08,0xF8,0x00,0x00,0x00]
    data.extend(page_b3)
    # Page B4 (some pattern data)
    page_b4 = [0x00]*13 + [0x0F,0x00,0x00,0x00,0x00,0x0F,0x00,0x00,0x06,0x08,0x08,0x08,0x07,0x00,0x00,0x1F,0x10,0x00,0x0F,0x08,0x00,0x07,0x08,0x08,0x0C,0x0F,0x00,0x00,0x0F,0x00,0x00,0x00,0x0F,0x00,0x00,0x00,0x0F,0x00,0x10,0x10,0x10,0x10,0x10,0x00,0x07,0x08,0x08,0x08,0x07,0x00,0x00,0x0F,0x00,0x00,0x0F,0x00,0x10,0x10,0x10,0x10,0x10,0x00,0x27,0x18,0x07,0x00,0x00,0x07,0x08,0x08,0x08,0x07,0x00,0x00,0x07,0x08,0x08,0x0C,0x0F,0x00,0x00,0x0F,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x00,0x0E,0x0A,0x0A,0x0F,0x00,0x00,0x0F,0x00,0x00,0x09,0x00,0x10,0x1F,0x00,0x00,0x00]
    data.extend(page_b4[:128])
    # Pages B5-B7 (all 0x00 - blank)
    data.extend([0x00] * 128 * 3)
    
    from PIL import Image
    img = Image.new('1', (128, 64), 0)
    pixels = img.load()
    
    for page in range(8):
        for col in range(128):
            byte = data[page*128 + col]
            for row in range(8):
                pixels[col, page*8 + row] = (byte >> (7-row)) & 1
    
    img = img.transpose(Image.FLIP_TOP_BOTTOM)  # OLED pages are top-to-bottom
    img.show()
    img.save('oled_flag.png')
    print("Flag image saved as oled_flag.png - check the image for flag text!")

<img width="400" height="250" alt="image" src="https://github.com/user-attachments/assets/3a563b20-762e-480a-9eec-1445c42f0d76" />

Output not good but it's readable, so get the flag!
 
FLAG:

    f13{turn_off_your_ai!}

